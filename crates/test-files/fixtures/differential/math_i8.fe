contract Foo {
    pub fn add(val1: i8, val2: i8) -> i8 {
        return val1 + val2
    }

    pub fn subtract(val1: i8, val2: i8) -> i8 {
        return val1 - val2
    }

    pub fn multiply(val1: i8, val2: i8) -> i8 {
        return val1 * val2
    }

    pub fn divide(val1: i8, val2: i8) -> i8 {
        return val1 / val2
    }

    pub fn pow(val1: i8, val2: u8) -> i8 {
        return val1 ** val2
    }

    pub fn modulo(val1: i8, val2: i8) -> i8 {
        return val1 % val2
    }

    pub fn rightshift(val1: i8, val2: u8) -> i8 {
        return val1 >> val2
    }

    pub fn leftshift(val1: i8, val2: u8) -> i8 {
        return val1 << val2
    }

    pub fn invert(val1: i8) -> i8 {
        return ~val1
    }

    pub fn cast1(val1: i8) -> u8 {
        return u8(val1)
    }

    pub fn cast2(val1: i8) -> u16 {
        return u16(u8(val1))
    }

    pub fn cast3(val1: i8) -> u16 {
        return u16(i16(val1))
    }

    pub fn order_of_operation(val1: i8, val2: i8, val3: u8) -> i8 {
        return val1 - val2 * (val1 + val2 / 4 * val1 - val2 ** val3) + val1
    }

    pub fn negate(val1: i8) -> i8 {
        return -val1
    }
}
